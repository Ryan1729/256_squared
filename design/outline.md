As of this writing we have the specific operation mentioned in the readme implemented. Now we ant to add more.

We currently have a way to vary the bits used in the operation as well. The type of the bits used is `i8` and we are using it to modify the `x` and `y` which are also `i8`s. We currently take an x and a y and apply a function to it and a user controlled offset which is also an `i8` and produce the final result `i8` from that. To vary to operation involved is to replace this two parameter function with another one. One can think of a two parameter function as a function that returns functions. Let |A| denote the number of possible values for a type A. The number of possible functions from type A -> B is |B| ^ |A|. This means here are "only" 256 ^ 256 ≈ 3.23 × 10^616 possible functions from `i8 -> i8` So there are 256 ^ (256 ^ 256) possible functions of that type, a number with approximately ≈ 7.782710558015685 × 10^616 decimal digits. We could represent each function as a `[[i8; 256]; 256]` and call it like so: `f[offset][x]`. This would take 65536 bytes to store.

To start off with we can just initialize this randomly, but it might be neat to pick a meaningful set of 65536 bytes and use that.

Future direction: This representation is a) frigging huge, and b) allows the same frame to show up in a set of 256 images. We could try reducing the size of the representation by disallowing duplicate frames, (which would correspond to duplicate entries in the outer array.) We might be able to reduce the size further by disregarding order of the frames, but that is less clearly a good tradeoff.
